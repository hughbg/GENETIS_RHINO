/********************************************* Function Calls **************************************************/


var file = new File(path);
file.open(1);
var generationDNA = file.readAll();

// Lists to hold the genes
var S=[];
//var m=[];
var H=[];
var X0=[]; // previously 0.04
var Y0=[]; // previously 0.04
var Z0=[];
var Xf=[];
var Yf=[];
var Zf=[];
var Beta=[];
var L=[];
var h=[];

var lines = generationDNA.split('\n');


for(var counter = indiv;counter<=NPOP;counter++)
{
	
	j = 1;
	Output.println(counter);

	
	// Loop over reading in the gene values
	for(var i = 0;i < lines.length;i++)
	{
		//Output.println(i);
		if(i==headerLines)
		{
			var frequencies = lines[i].split(",");
		}
    	if(i>=antennaLines)
        {
        	var params = lines[i].split(",");

			S[i-antennaLines]=params[0]/100;
			H[i-antennaLines]=params[1]/100;
			//m[i-antennaLines]=params[0];
			X0[i-antennaLines]=params[2]/100; // previously 0.04
			Y0[i-antennaLines]=params[3]/100; // previously 0.04
			Z0[i-antennaLines]=0;
			//xf[i-antennaLines]=params[0];
			Yf[i-antennaLines]=params[4]/100; // Preferably swap this order in the GA!!
			Zf[i-antennaLines]=params[5]/100;
			Beta[i-antennaLines]=params[6];
			L[i-antennaLines]=params[7]/100;
			h[i-antennaLines]=params[8]/100;

			//Output.println(S[i-antennaLines]);
			//Output.println(H[i-antennaLines]);
			//Output.println(X0[i-antennaLines]);
			//Output.println(Y0[i-antennaLines]);
			//Output.println(Yf[i-antennaLines]);
			//Output.println(Zf[i-antennaLines]);
			//Output.println(Beta[i-antennaLines]);
		}
	}
}

for(var i = indiv; i <= NPOP;i++)
{
	
		var s = S[i];
		var h = H[i];
		var x0 = X0[i];
		var y0 = Y0[i];
		var z0 = 0;
		var xf = s; // By constraint
		var yf = Yf[i];
		var zf = Zf[i];
		var beta = Beta[i];
		var l = L[i];
		var th = L[i];
		var m = 1;
		var d = 0.03;


		//T = Tau/(Math.exp(zf/beta)-1)*(Math.exp(height/beta)-1);
		//X = 1*x0 + (zf-x0)/Tau * T; // Multiply x0 by 1 because otherwise it doesn't know it's a number lol
		//Output.println(T);
		//Output.println(X);

		Output.println(x0);
		Output.println(y0);
		Output.println(z0);
		Output.println(xf);
		Output.println(yf);
		Output.println(zf);
		Output.println(beta);
		Output.println(s);
		Output.println(h);


		// Function calls
		// We do it twice, first for horizontal source then for vertical
		for(var k = 0; k <= SYMMETRY; k++)
		{

			if(k == 0)
			{
				height = -height1;
			}
			else
			{
				height = -height2;
			}
			T = Tau/(Math.exp(zf/beta)-1)*(Math.exp(height/beta)-1);
			X = 1*x0 + (zf-x0)/Tau * T; // Multiply x0 by 1 because otherwise it doesn't know it's a number lol

			//l = (x0-y0)/4; //arbitrary
			Output.println(l);
			Output.println(x0);
			Output.println(y0);
			App.getActiveProject().getGeometryAssembly().clear();
			CreatePEC();
			build_waveguide(1*s, 1*x0,1*y0,-1*d);
			//extend_ridges(1*s, 1*x0,1*y0,-1*d);
			extend_ridges_trapezoid(1*s, 1*x0,1*y0,-1*d, 1*l, 1*th);
			build_walls(s,m,h);
			//build_walls(s,-m,-h);
			build_ridges(1*x0, 1*y0, 1*z0, 1*xf, 1*yf, 1*zf, 1*Tau, beta, 1*s/100, 1*m); 
			//build_ridges(1*x0, 1*y0, 1*z0, 1*xf, 1*yf, -1*zf, 1*Tau, -beta, 1*s/100, 1*m); // trying to make a second one pointing at the first
			CreateAntennaSource(k, 1*x0, 1*y0, height, 1*l); 
			CreateGrid(1*x0, 1*y0, 1*d);
			CreateSensors();
			CreateAntennaSimulationData();
			QueueSimulation();
			Output.println(ResultQuery().simulationId);
			MakeImage(i);
		}
	
}

file.close();
App.quit();
